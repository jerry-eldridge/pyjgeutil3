from scipy.integrate import quad
from math import sqrt,pi,acos,cos,sin,pi,fmod
import matplotlib.pyplot as plt
import numpy as np
import sounddevice as sd
import time
import random

seed0 = 12345
random.seed(seed0)

# Here a and b are real numbers and f,g,h,etc are functions
# the L2_Inner,L2_Norm,L2_Angle functions are curried in part
# so that you input interval [a,b] returning a function acting upon
# input functions. That is, instead of L2_Inner(a,b,f,g),etc we have
# L2_Inner(a,b)(f,g), L2_Norm(a,b)(f), and L2_Angle(a,b)(f,g).
# The inner product space defined is called L**2[a,b] given the inner
# product L2_Inner(a,b). The inner product induces a norm, so L**2[a,b]
# is a normed space with L2_norm(a,b) and a metric space with L2_d(a,b).
# And L**2[a,b] is a Hausdorff Topology given open sets generated by
# basis the balls B(f,epsilon) = {g: L2_d(a,b)(f,g)<epsilon}.
# elements of L**2[a,b] are functions with Integral(f**2,a,b,dx) < oo
# in pseudo-code. Namely sqr = lambda f: lambda x: f(x)*f(x) and f**2 = 
# sqrt(f).

# Vector space of functions over the field of real numbers
add = lambda f,g: lambda x: f(x)+g(x) # f+g is addition of functions, 
minus = lambda f: lambda x: -f(x)
    # -f is additive inverse of function f, minus(f)(x)
smul = lambda a,f: lambda x: a*f(x)
    # a*f is multiplication of function f by a scalar a, smul(a,f)(x)
# Plus function products f*g
mul = lambda f,g: lambda x: f(x)*g(x) # mul(f,g)(x)
# Plus function composition f o g, one type of "multiplication"
# Note that function inverse f**(-1) is multiplicative inverse using
# compose as multiplication. Namely that g such that f o g = one function.
one = lambda x: x # one(x)
compose = lambda f,g: lambda x: f(g(x)) # compose(f,g)(x)
# Plus function f/g
div = lambda f,g: lambda x: f(x)/g(x) # div(f,g)(x)
# Note that div(one,f) denoted 1/f is not "f inverse" f**(-1).

def Integral(f,a,b,dx=0.001):
     return quad(f,a,b)[0]
    
# L**2[a,b] function space's inner product L2_Inner(a,b)(f,g)
# the inner product of f and g
def L2_Inner(a,b):
     def inner(f,g):
         h = mul(f,g) # h = f*g with * function product
         return Integral(h,a,b)
     return inner

# L**2[a,b] function space's norm L2_Norm(a,b)(f)
# the norm of f
def L2_Norm(a,b):
     def norm(f):
         return sqrt(L2_Inner(a,b)(f,f))
     return norm

# L**2[a,b] function space's metric L2_d(a,b)(f,g)
# distance between f and g.
def L2_d(a,b):
     def d(f,g):
         h = lambda x: f(x) - g(x)
         return L2_Norm(a,b)(h)
     return d

# L**2[a,b] function space's angle between functions f,g as 
# L2_Angle(a,b)(f,g)
def L2_Angle(a,b):
     def angle(f,g):
         A = L2_Norm(a,b)(f)
         B = L2_Norm(a,b)(g)
         return acos(1.0*L2_Inner(a,b)(f,g)/(A*B))*180.0/pi
     return angle

# define orthogonal basis functions the constants sqrt(pi), etc
# are to normalize so that inner(phi(n),phi(m)) = 1 if n == m and 0
# if n != m.
def phi(n):
     if n == 0:
         def p(x):
             return 1.0/sqrt(2*pi)
     elif n%2 == 0:
         def p(x):
             return cos((n/2)*x)/sqrt(pi)
     elif n%2 == 1:
         def p(x):
             return sin((n+1)/2*x)/sqrt(pi)
     else:
         print("Error")
         return None
     return p

# Fourier transform, continuous    
def Fourier(f):
     def FT(n):
         g = phi(n)
         return L2_Inner(-pi,pi)(f,g)
     return FT

# in l**2
def FourierVector(f,N=10):
     # Fourier Series vector representation of f using eg N = 10 dimensions
     v = list(map(lambda n: Fourier(f)(n), range(N)))
     return v

# Inputs a Fourier vector representation and outputs a function
# of x.
def FourierEval(v):
     N = len(v)
     def f(x):  
         s = 0
         for n in range(N):
             s = s + v[n]*phi(n)(x)
         return s
     return f

# function to be approximated, is in L**2
# domain used for function, keep small
a,b = -pi,pi
sr = 44100 # samples per second (sampling rate)

lerp = lambda x,y,t: x*(1-t) + y*t
clamp = lambda x,lo,hi: min(hi,max(lo,x))

def ramp_wave0(x):
     t = fmod(5+x,1) # in [0,1]
     val = lerp(-1,1,t)
     return val
def sine_wave0(x):
     t = fmod(5+x,1) # in [0,1]
     val = sin(2*pi*x)
     return val
def square_wave0(x):
    t = fmod(5+x,1) # in [0,1]
    if 0 <= t < 0.5:
        return .75
    else:
        return -.75
# vocal cord vibration
def vocal_wave0(x):
    t = fmod(5+x,1) # in [0,1]
    val = 0.01
    if 0 <= t < 0.5:
        val = lerp(-1,1,2*t)
    elif 0.5 <= t <= 1.0:
        val = lerp(1,-1,2*(t-0.5))
    return val

# list of timbres (arbitrary function but
# defined on domain [a,b] of range in [-1,1]

def timbre_f1(func,freq):
     def f(x): # domain in [a,b]
          t = fmod((x-a)/(b-a),1)
          return func(freq*t)
     return f

def timbre_f2(func,freq):
     def f(t):
          x = 2*pi*(t-0.5)
          return func(freq*x)
     return f

def F1(f):
     return timbre_f1(f,1)

# sequence in l**2 approximating function f
print(f"Possible Timbres:")
v_f_ramp_wave = FourierVector(F1(ramp_wave0),N=20)
print(f" v_f_ramp_wave = {v_f_ramp_wave}")
v_f_sine_wave = FourierVector(F1(sine_wave0),N=20)
print(f" v_f_sine_wave = {v_f_sine_wave}")
v_f_square_wave = FourierVector(F1(square_wave0),N=20)
print(f" v_f_square_wave = {v_f_square_wave}")
v_f_vocal_wave = FourierVector(F1(vocal_wave0),N=20)
print(f" v_f_vocal_wave = {v_f_vocal_wave}")
v_f_custom_wave = [0,.4,.3,0,-.1,.2,-.3]
xx = np.array(v_f_custom_wave)
scale_volume = .6
xx = scale_volume*xx/np.linalg.norm(xx)
xx = list(map(float,list(xx)))
v_f_custom_wave = xx
print(f" v_f_custom_wave = {v_f_custom_wave}")

# sequence converted to L**2 approximating f
ramp_wave = FourierEval(v_f_ramp_wave)
sine_wave = FourierEval(v_f_sine_wave)
square_wave = FourierEval(v_f_square_wave)
vocal_wave = FourierEval(v_f_vocal_wave)
custom_wave = FourierEval(v_f_custom_wave)

# set timbre2 to vocal_wave
timbre2 = vocal_wave # set timbre2 (vocal_wave)

fade = 2
volume_hi = .8
volume_lo = .4
noise0 = 0.0125
noise = lambda t: noise0*random.uniform(-1,1)
volume2 = lambda t: volume_hi
g = lambda freq: lambda t: \
    volume2(t)*(timbre_f2(timbre2,freq)(t)+noise(t))

def song_array(fn,sr):
    f = open(fn,'r')
    txt = f.read()
    f.close()
    lines = txt.split('\n')
    L = []
    total_dur = 0
    for line in lines:
        if len(line) == 0:
            continue
        toks = line.split(',')
        if len(toks) != 3:
            continue
        toks = list(map(float,toks))
        t_start,freq,t_end = toks
        t_start2 = t_start/1000.0
        t_end2 = t_end/1000.0
        dur = t_end2-t_start2
        total_dur = total_dur + dur
        tup = (t_start2,t_end2,freq)
        #print(tup)
        L.append(tup)
    s_t = int(total_dur*sr)
    X = np.zeros(s_t,dtype=np.float64)
    s = 0
    for tup in L:
        print(f"adding ... tup = {tup}")
        t_start2,t_end2,freq = tup
        dur = t_end2-t_start2
        s1 = int(t_start2*sr)
        s2 = int(t_end2*sr)
        n_t = s2 - s1
        t = np.linspace(t_start2,t_end2,n_t)
        X_tup = np.array(list(map(g(freq),t)),\
                        dtype=np.float64)
        X[s1:s2] = X[s1:s2] + X_tup
    sd.play(X,sr)

    TT = np.linspace(0,1,int(sr*1))
    YY = list(map(timbre_f2(timbre2,5), TT))
    t0 = time.time()
    plt.plot(TT,YY,'b')
    plt.show()
    t1 = time.time()
    dt = t1 - t0
    time.sleep(max(0,total_dur-dt))
    return

fn = "./jerry_dances_to_autumn_in_paradise.txt"
song_array(fn,sr)

