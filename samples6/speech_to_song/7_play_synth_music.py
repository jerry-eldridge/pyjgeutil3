import scipy.io as si
import parselmouth as pm
from collections import namedtuple

from math import log

import os
import fnmatch
import os.path

from scipy.integrate import quad
from math import sqrt,pi,acos,cos,sin,pi,fmod
import matplotlib.pyplot as plt
import numpy as np
import sounddevice as sd
import time
import random
import scipy.io.wavfile as wavf

seed0 = 12345
random.seed(seed0)

# Here a and b are real numbers and f,g,h,etc are functions
# the L2_Inner,L2_Norm,L2_Angle functions are curried in part
# so that you input interval [a,b] returning a function acting upon
# input functions. That is, instead of L2_Inner(a,b,f,g),etc we have
# L2_Inner(a,b)(f,g), L2_Norm(a,b)(f), and L2_Angle(a,b)(f,g).
# The inner product space defined is called L**2[a,b] given the inner
# product L2_Inner(a,b). The inner product induces a norm, so L**2[a,b]
# is a normed space with L2_norm(a,b) and a metric space with L2_d(a,b).
# And L**2[a,b] is a Hausdorff Topology given open sets generated by
# basis the balls B(f,epsilon) = {g: L2_d(a,b)(f,g)<epsilon}.
# elements of L**2[a,b] are functions with Integral(f**2,a,b,dx) < oo
# in pseudo-code. Namely sqr = lambda f: lambda x: f(x)*f(x) and f**2 = 
# sqrt(f).

# Vector space of functions over the field of real numbers
add = lambda f,g: lambda x: f(x)+g(x) # f+g is addition of functions, 
minus = lambda f: lambda x: -f(x)
    # -f is additive inverse of function f, minus(f)(x)
smul = lambda a,f: lambda x: a*f(x)
    # a*f is multiplication of function f by a scalar a, smul(a,f)(x)
# Plus function products f*g
mul = lambda f,g: lambda x: f(x)*g(x) # mul(f,g)(x)
# Plus function composition f o g, one type of "multiplication"
# Note that function inverse f**(-1) is multiplicative inverse using
# compose as multiplication. Namely that g such that f o g = one function.
one = lambda x: x # one(x)
compose = lambda f,g: lambda x: f(g(x)) # compose(f,g)(x)
# Plus function f/g
div = lambda f,g: lambda x: f(x)/g(x) # div(f,g)(x)
# Note that div(one,f) denoted 1/f is not "f inverse" f**(-1).

def Integral(f,a,b,dx=0.001):
     return quad(f,a,b)[0]
    
# L**2[a,b] function space's inner product L2_Inner(a,b)(f,g)
# the inner product of f and g
def L2_Inner(a,b):
     def inner(f,g):
         h = mul(f,g) # h = f*g with * function product
         return Integral(h,a,b)
     return inner

# L**2[a,b] function space's norm L2_Norm(a,b)(f)
# the norm of f
def L2_Norm(a,b):
     def norm(f):
         return sqrt(L2_Inner(a,b)(f,f))
     return norm

# L**2[a,b] function space's metric L2_d(a,b)(f,g)
# distance between f and g.
def L2_d(a,b):
     def d(f,g):
         h = lambda x: f(x) - g(x)
         return L2_Norm(a,b)(h)
     return d

# L**2[a,b] function space's angle between functions f,g as 
# L2_Angle(a,b)(f,g)
def L2_Angle(a,b):
     def angle(f,g):
         A = L2_Norm(a,b)(f)
         B = L2_Norm(a,b)(g)
         return acos(1.0*L2_Inner(a,b)(f,g)/(A*B))*180.0/pi
     return angle

# define orthogonal basis functions the constants sqrt(pi), etc
# are to normalize so that inner(phi(n),phi(m)) = 1 if n == m and 0
# if n != m.
def phi(n):
     if n == 0:
         def p(x):
             return 1.0/sqrt(2*pi)
     elif n%2 == 0:
         def p(x):
             return cos((n/2)*x)/sqrt(pi)
     elif n%2 == 1:
         def p(x):
             return sin((n+1)/2*x)/sqrt(pi)
     else:
         print("Error")
         return None
     return p

# Fourier transform, continuous    
def Fourier(f):
     def FT(n):
         g = phi(n)
         return L2_Inner(-pi,pi)(f,g)
     return FT

# in l**2
def FourierVector(f,N=10):
     # Fourier Series vector representation of f using eg N = 10 dimensions
     v = list(map(lambda n: Fourier(f)(n), range(N)))
     return v

# Inputs a Fourier vector representation and outputs a function
# of x.
def FourierEval(v):
     N = len(v)
     def f(x):  
         s = 0
         for n in range(N):
             s = s + v[n]*phi(n)(x)
         return s
     return f

# function to be approximated, is in L**2
# domain used for function, keep small
a,b = -pi,pi
sr = 44100 # samples per second (sampling rate)

lerp = lambda x,y,t: x*(1-t) + y*t
clamp = lambda x,lo,hi: min(hi,max(lo,x))

def ramp_wave0(x):
     t = fmod(5+x,1) # in [0,1]
     val = lerp(-1,1,t)
     return val
def sine_wave0(x):
     t = fmod(5+x,1) # in [0,1]
     val = sin(2*pi*x)
     return val
def square_wave0(x):
    t = fmod(5+x,1) # in [0,1]
    if 0 <= t < 0.5:
        return .75
    else:
        return -.75
# vocal cord vibration
def vocal_wave0(x):
    t = fmod(5+x,1) # in [0,1]
    val = 0.01
    if 0 <= t < 0.5:
        val = lerp(-1,1,2*t)
    elif 0.5 <= t <= 1.0:
        val = lerp(1,-1,2*(t-0.5))
    return val

# list of timbres (arbitrary function but
# defined on domain [a,b] of range in [-1,1]

def timbre_f1(func,freq):
     def f(x): # domain in [a,b]
          t = fmod((x-a)/(b-a),1)
          return func(freq*t)
     return f

def timbre_f2(func,freq):
     def f(t):
          x = 2*pi*(t-0.5)
          return func(freq*x)
     return f

def F1(f):
     return timbre_f1(f,1)

# sequence in l**2 approximating function f
print(f"Possible Timbres:")
v_f_ramp_wave = FourierVector(F1(ramp_wave0),N=20)
print(f" v_f_ramp_wave = {v_f_ramp_wave}")
v_f_sine_wave = FourierVector(F1(sine_wave0),N=20)
print(f" v_f_sine_wave = {v_f_sine_wave}")
v_f_square_wave = FourierVector(F1(square_wave0),N=20)
print(f" v_f_square_wave = {v_f_square_wave}")
v_f_vocal_wave = FourierVector(F1(vocal_wave0),N=20)
print(f" v_f_vocal_wave = {v_f_vocal_wave}")
v_f_custom_wave = [0,.4,.3,0,-.1,.2,-.3]
xx = np.array(v_f_custom_wave)
scale_volume = .6
xx = scale_volume*xx/np.linalg.norm(xx)
xx = list(map(float,list(xx)))
v_f_custom_wave = xx
print(f" v_f_custom_wave = {v_f_custom_wave}")

# sequence converted to L**2 approximating f
ramp_wave = FourierEval(v_f_ramp_wave)
sine_wave = FourierEval(v_f_sine_wave)
square_wave = FourierEval(v_f_square_wave)
vocal_wave = FourierEval(v_f_vocal_wave)
custom_wave = FourierEval(v_f_custom_wave)

# set timbre2 to vocal_wave
timbre2 = square_wave # set timbre2 (vocal_wave)

fade = 2
volume_hi = .8
volume_lo = .4
noise0 = 0.0125
noise = lambda t: noise0*random.uniform(-1,1)
volume2 = lambda t: volume_hi
def g(freq,vol):
    def f(t):
        val = (vol/2000.0)*(timbre_f2(timbre2,freq)(t)+\
                           noise(t))
        return val
    return f

def song_array(fn,sr, fn_save):
    f = open(fn,'r')
    txt = f.read()
    f.close()
    lines = txt.split('\n')
    L = []
    total_dur = 0
    for line in lines:
        if len(line) == 0:
            continue
        toks = line.split(',')
        if len(toks) < 3:
            continue
        toks = list(map(float,toks))
        t_start,freq,t_end,vol = toks
        t_start2 = t_start/1000.0
        t_end2 = t_end/1000.0
        dur = t_end2-t_start2
        total_dur = total_dur + dur
        tup = (t_start2,t_end2,freq,vol)
        #print(tup)
        L.append(tup)
    s_t = int(total_dur*sr)
    X = np.zeros(s_t,dtype=np.float64)
    s = 0
    for tup in L:
        print(f"adding ... tup = {tup}")
        t_start2,t_end2,freq,vol = tup
        dur = t_end2-t_start2
        s1 = int(t_start2*sr)
        s2 = int(t_end2*sr)
        n_t = s2 - s1
        t = np.linspace(t_start2,t_end2,n_t)
        X_tup = np.array(list(map(g(freq,vol),t)),\
                        dtype=np.float64)
        X[s1:s2] = X[s1:s2] + X_tup
    sd.play(X,sr)

    # save audio to fn_save
    X16 = np.int16(X/np.max(np.abs(X))*20767)
    print(f"saving audio as {fn_save}")
    wavf.write(fn_save, sr, X16)    
    TT = np.linspace(0,1,int(sr*1))
    YY = list(map(timbre_f2(timbre2,5), TT))
    t0 = time.time()
    plt.plot(TT,YY,'b')
    plt.show()
    t1 = time.time()
    dt = t1 - t0
    #time.sleep(max(0,total_dur-dt))
    return


def piano_freq(note):
    val = 440*2**((note-49)/12.)
    return val
def piano_note(freq):
    n = int(12 * log(freq/440.0)/log(2) + 49)
    return n
def piano_note_name(n):
    names = ["A","A#","B","C","C#","D",
             "D#","E","F","F#","G","G#"]
    idx = (12+n-1)%12
    octave = int((n-1)/12 + 1)
    name = names[idx]+str(octave)
    return name

def ListFiles(folder,pattern):
    L = []
    for root, dire, files in os.walk(folder):
        for fn in fnmatch.filter(files, pattern):
            try:
                root = root.replace('\\','/')
                fn = fn.replace('\\','/')
                filename = root + '/' + fn
                mtime = int(os.path.getmtime(filename))
                ctime = int(os.path.getctime(filename))
                L.append((ctime,mtime,root,fn))
            except:
                continue
    return L

def DisplayVowels(fn_save, L,N=2):
    #sr,x = si.wavfile.read(fn)
    gg = open(fn_save,'w')
    for tup in L:
        secs1,secs2,root_t,fn_t = tup
        fn = root_t + fn_t
        print(f"fn = \"{fn}\"")
        snd = pm.Sound(fn)
        pitch = snd.to_pitch()
        pitch_vals = pitch.selected_array['frequency']
        dur = snd.duration
        print(f"dur = {dur} seconds")
        dt = 1.0/4.0 # sec
        N = pitch_vals.shape[0]
        M = 20
        for i in range(M,N,M):
            t2 = pitch.xs()[i]
            t1 = pitch.xs()[i-M]
            F1 = pitch_vals[i]
            F2 = 2*F1
            F3 = 3*F1
            V1 = 400
            V2 = 400
            V3 = 400
            if F1 < 15:
                continue
            F1 = piano_freq(piano_note(F1))
            F2 = piano_freq(piano_note(F2))
            F3 = piano_freq(piano_note(F3))
            rec = Ftup(*[F1,V1,F2,V2,F3,V3])
            txt = f"{int(t1*1000)},"+\
                  f"{int(F1)},"+\
                  f"{int(t2*1000)},"+\
                  f"{V1}\n"
            gg.write(txt)
            txt = f"{int(t1*1000)},"+\
                  f"{int(F2)},"+\
                  f"{int(t2*1000)},"+\
                  f"{V2}\n"
            gg.write(txt)
            txt = f"{int(t1*1000)},"+\
                  f"{int(F3)},"+\
                  f"{int(t2*1000)},"+\
                  f"{V3}\n"
            gg.write(txt)
    gg.close()
    return

Ftup = namedtuple("Ftup",["F1","V1","F2","V2",
                          "F3","V3"])

##C:\Users\jerry>cd c:\_Python313-64-tf
##c:\_Python313-64-tf>.\python -m pip install praat-parselmouth
##c:\_Python313-64-tf>.\python -m pip install seaborn

root = r"./audio2/"
root_A = root
root1 = r"./songs1/"
root2 = r"./songs2/"
root3 = r"./songs3/"
root_B = root3
L = ListFiles(root_A,"*.wav")
n = 1
for fn in L:
    fn_save = root_B+f"tmptmp-{n:04d}.txt"
    ## uncomment to create tmptmp-nnnn.txt files
    ## from .wav files in ./audio/ folder.
    
    #DisplayVowels(fn_save,[fn],N=10)
    
    n = n + 1
N = len(L)
N = 2
L2 = ListFiles(root_B,"*.txt")
for n in range(len(L2)):
     tup = L2[n]
     fn = tup[2]+tup[3]
     print(fn)
     fn_audio_save = root_B+f"song-{n:04d}.wav"
     song_array(fn,sr,fn_audio_save)


