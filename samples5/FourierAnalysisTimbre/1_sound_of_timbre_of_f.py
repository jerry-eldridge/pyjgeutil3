from scipy.integrate import quad
from math import sqrt,pi,acos,cos,sin,pi
import matplotlib.pyplot as plt
import numpy as np
import sounddevice as sd
import time

# Here a and b are real numbers and f,g,h,etc are functions
# the L2_Inner,L2_Norm,L2_Angle functions are curried in part
# so that you input interval [a,b] returning a function acting upon
# input functions. That is, instead of L2_Inner(a,b,f,g),etc we have
# L2_Inner(a,b)(f,g), L2_Norm(a,b)(f), and L2_Angle(a,b)(f,g).
# The inner product space defined is called L**2[a,b] given the inner
# product L2_Inner(a,b). The inner product induces a norm, so L**2[a,b]
# is a normed space with L2_norm(a,b) and a metric space with L2_d(a,b).
# And L**2[a,b] is a Hausdorff Topology given open sets generated by
# basis the balls B(f,epsilon) = {g: L2_d(a,b)(f,g)<epsilon}.
# elements of L**2[a,b] are functions with Integral(f**2,a,b,dx) < oo
# in pseudo-code. Namely sqr = lambda f: lambda x: f(x)*f(x) and f**2 = 
# sqrt(f).

# Vector space of functions over the field of real numbers
add = lambda f,g: lambda x: f(x)+g(x) # f+g is addition of functions, 
minus = lambda f: lambda x: -f(x)
    # -f is additive inverse of function f, minus(f)(x)
smul = lambda a,f: lambda x: a*f(x)
    # a*f is multiplication of function f by a scalar a, smul(a,f)(x)
# Plus function products f*g
mul = lambda f,g: lambda x: f(x)*g(x) # mul(f,g)(x)
# Plus function composition f o g, one type of "multiplication"
# Note that function inverse f**(-1) is multiplicative inverse using
# compose as multiplication. Namely that g such that f o g = one function.
one = lambda x: x # one(x)
compose = lambda f,g: lambda x: f(g(x)) # compose(f,g)(x)
# Plus function f/g
div = lambda f,g: lambda x: f(x)/g(x) # div(f,g)(x)
# Note that div(one,f) denoted 1/f is not "f inverse" f**(-1).

def Integral(f,a,b,dx=0.001):
     return quad(f,a,b)[0]
    
# L**2[a,b] function space's inner product L2_Inner(a,b)(f,g)
# the inner product of f and g
def L2_Inner(a,b):
     def inner(f,g):
         h = mul(f,g) # h = f*g with * function product
         return Integral(h,a,b)
     return inner

# L**2[a,b] function space's norm L2_Norm(a,b)(f)
# the norm of f
def L2_Norm(a,b):
     def norm(f):
         return sqrt(L2_Inner(a,b)(f,f))
     return norm

# L**2[a,b] function space's metric L2_d(a,b)(f,g)
# distance between f and g.
def L2_d(a,b):
     def d(f,g):
         h = lambda x: f(x) - g(x)
         return L2_Norm(a,b)(h)
     return d

# L**2[a,b] function space's angle between functions f,g as 
# L2_Angle(a,b)(f,g)
def L2_Angle(a,b):
     def angle(f,g):
         A = L2_Norm(a,b)(f)
         B = L2_Norm(a,b)(g)
         return acos(1.0*L2_Inner(a,b)(f,g)/(A*B))*180.0/pi
     return angle

# define orthogonal basis functions the constants sqrt(pi), etc
# are to normalize so that inner(phi(n),phi(m)) = 1 if n == m and 0
# if n != m.
def phi(n):
     if n == 0:
         def p(x):
             return 1.0/sqrt(2*pi)
     elif n%2 == 0:
         def p(x):
             return cos((n/2)*x)/sqrt(pi)
     elif n%2 == 1:
         def p(x):
             return sin((n+1)/2*x)/sqrt(pi)
     else:
         print("Error")
         return None
     return p

# Fourier transform, continuous    
def Fourier(f):
     def FT(n):
         g = phi(n)
         return L2_Inner(-pi,pi)(f,g)
     return FT

# in l**2
def FourierVector(f,N=10):
     # Fourier Series vector representation of f using eg N = 10 dimensions
     v = list(map(lambda n: Fourier(f)(n), range(N)))
     return v

# Inputs a Fourier vector representation and outputs a function
# of x.
def FourierEval(v):
     N = len(v)
     def f(x):
         s = 0
         for n in range(N):
             s += v[n]*phi(n)(x)
         return s
     return f

# function to be approximated, is in L**2
f = lambda x: x/(2*pi)

# domain used for function, keep small
a,b = -pi,pi
# sequence in l**2 approximating function f
v_f = FourierVector(f,N=20)
print(f"v_f = {v_f}")
# sequence converted to L**2 approximating f
timbre = FourierEval(v_f)

volume = .8 # in range [0,1]
freq = 100 # Hz
g = lambda x: volume*timbre(freq*x)

# plot function by calculating domain X
dur = 2 # duration in seconds
sr = 44100 # samples per second
n_t = int(dur*sr)
t = np.linspace(a,b,n_t)
# range Y1 for f and range Y2 for f_approx
Y1 = np.array(list(map(g, t)),dtype=np.float64)
sd.play(Y1,sr)
time.sleep(dur)




