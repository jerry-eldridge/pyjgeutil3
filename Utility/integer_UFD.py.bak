# div(a,b) for a,b in integers makes the integers
# a Euclidean domain where div is long division.
def div(a,b):
    """
    div(a,b) does a/b = q + r/b returning (q,r)
    and implementing a long division of integers.
    The remainder is calculated with r = a % b
    and quotient found with that remainder.
    The a % b implements Euclidean algorithm built
    into python to return the remainder r.
    """
    r = a % b
    q = (a - r)/b
    return (q,r)

# primes(maxprime) returns a list of prime numbers
# up to maxprime.
def primes(maxprime = 100000):
    # store list of primes in primes.txt in
    # folder 'C:/_BigData/PRIMES'. One can list
    # a few primes manually. The primes.txt was
    # generated by a C++ program and variant of
    # Sieve of Eratostanes or prime sieving algorithm.
    try:
        f = open("C:/_BigData/PRIMES/primes.txt")
    except:
        f = open("C:/_BigData/PRIMES/primes_small.txt")
    txt = f.read()
    f.close()
    lines = txt.split("\n")
    L = []
    for line in lines:
        toks = line.split(" ")
        if len(toks) != 2:
            continue
        n,p = toks
        n = int(n)
        p = int(p)
        if p > maxprime:
            break
        L.append(p)
    return L

# create list of prime numbers
P = primes()

# makes the integers a unique factorization
# domain (UFD)
def factorint(n):
    """
    factorint(12) returns {2: 2, 3: 1}
    where a:b means key of prime number a
    and b is multiplicity of that prime.
    So 12 = 2**2 * 3*1 is unique factorization.
    This makes the integers a unique factorization
    domain (UFD).
    """
    global P
    n = abs(n)
    d = {}
    while n > 1:
        for p in P:
            q,r = div(n,p)
            if r == 0:
                n2 = q
                try:
                    d[p] += 1
                except:
                    d[p] = 1
                break
        if n2 == n:
            n = n2
            break
        n = n2
    return d

def DirectProd2(A,B):
    """
    DirectProd2(A,B) for
    A = [1,2] and B = [2,3,5] for example
    will find A x B the direct product
    and then (a,b) in A x B produce c = (a,b)
    and return list L of such c.
    """
    L = []
    for a in A:
        for b in B:
            c = (a,b)
            if c not in L:
                L.append(c)
    return L

def DirectProdMul(A,B):
    """
    DirectProdMul(A,B) does DirectProd2(A,B)
    finding A x B and for c in A x B where c = (a,b)
    with a in A and b in B adds d = a*b to returned
    list where A and B are list of integers.
    This is a helper function for factors(n).
    """
    L = DirectProd2(A,B)
    L2 = []
    for c in L:
        a,b = c
        d = a*b
        if d not in L2:
            L2.append(d)
    L2.sort()
    return L2
    
def DirectProd(B0, L):
    """
    DirectProd([1,2],[[2,3,5],[3,4]])
    does the DirectProd2 function on a a list B0
    and list of lists L of integers.
    This is a helper function used by factors().
    """
    if len(L) == 0:
        return B0
    L2 = DirectProdMul(B0,L[0])
    if len(L) == 1:
        return L2
    else:
        return DirectProd(L2,L[1:])

# find all possible factors of an integer n
def factors(n):
    """
    factors(n) returns a list of all factors of
    integer n. Eg, factors(100) returns
    [1, 2, 4, 5, 10, 20, 25, 50, 100].
    """
    d = factorint(n)
    K = d.keys()
    I = range(len(K))
    J = map(lambda i: d[K[i]],I)
    f = 1
    B = []
    for i in I:
        A = []
        for j in range(J[i]+1):
            a = K[i]**j
            A.append(a)
        B.append(A)
    if len(B) == 0:
        return [1]
    if len(B) == 1:
        B[0].sort()
        return B[0]

    if len(B) > 1:
        return DirectProd(B[0],B[1:])
    return B

def rational_factors(a,b):
    """
    Finds all rational factors tuples (n,m)
    where n is a factor of a and m is a factor of b
    plus minus signs +1 or -1 factors.
    rational_factors(a,b) - where a and b are integers.
    """
    A = factors(a)
    B = [1,-1]
    L1 = DirectProdMul(A,B)
    L2 = factors(b)
    L = DirectProd2(L1,L2)
    return L
